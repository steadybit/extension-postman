// Package attack_kit_api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.1-0.20220629212257-2cf7fcf5b26d DO NOT EDIT.
package attack_kit_api

import (
	"encoding/json"
)

// Defines values for AttackDescriptionKind.
const (
	ATTACK   AttackDescriptionKind = "ATTACK"
	CHECK    AttackDescriptionKind = "CHECK"
	LOADTEST AttackDescriptionKind = "LOAD_TEST"
	OTHER    AttackDescriptionKind = "OTHER"
)

// Defines values for AttackDescriptionTimeControl.
const (
	EXTERNAL      AttackDescriptionTimeControl = "EXTERNAL"
	INSTANTANEOUS AttackDescriptionTimeControl = "INSTANTANEOUS"
	INTERNAL      AttackDescriptionTimeControl = "INTERNAL"
)

// Defines values for AttackParameterType.
const (
	Boolean     AttackParameterType = "boolean"
	Duration    AttackParameterType = "duration"
	File        AttackParameterType = "file"
	Integer     AttackParameterType = "integer"
	KeyValue    AttackParameterType = "key_value"
	Password    AttackParameterType = "password"
	Percentage  AttackParameterType = "percentage"
	String      AttackParameterType = "string"
	String1     AttackParameterType = "string[]"
	StringArray AttackParameterType = "string_array"
)

// Defines values for DescribingEndpointReferenceMethod.
const (
	GET DescribingEndpointReferenceMethod = "GET"
)

// Defines values for MessageLevel.
const (
	Debug MessageLevel = "debug"
	Error MessageLevel = "error"
	Info  MessageLevel = "info"
)

// Defines values for MutatingHttpMethod.
const (
	DELETE MutatingHttpMethod = "DELETE"
	POST   MutatingHttpMethod = "POST"
	PUT    MutatingHttpMethod = "PUT"
)

// Attacks may choose to provide artifacts (arbitrary files) that are later accessible by users when inspecting experiment execution details. This comes in handy to expose load test reports and similar data.
type Artifact struct {
	// base64 encoded data
	Data string `json:"data"`

	// Human-readable label for the artifact. We recommend to include file extensions within the label for a better user-experience when downloading these artifacts, e.g., load_test_result.tar.gz.
	Label string `json:"label"`
}

// Artifacts defines model for Artifacts.
type Artifacts = []Artifact

// Provides details about a possible attack, e.g., what configuration options it has, how to present it to end-users and how to trigger the attack.
type AttackDescription struct {
	// Used for categorization of the attack within user interfaces.
	Category *string `json:"category,omitempty"`

	// Description for end-users to help them understand what the attack is doing.
	Description string `json:"description"`

	// An icon that is used to identify your attack in the ui. Needs to be a data-uri containing an image.
	Icon *string `json:"icon,omitempty"`

	// A technical ID that is used to uniquely identify this type of attack. You will typically want to use something like `org.example.attacks.my-fancy-attack`.
	Id string `json:"id"`

	// Describes what kind of attack this is. This is used to help users understand and classify the various runnable actions that are part of an experiment.
	Kind AttackDescriptionKind `json:"kind"`

	// A human-readable label for the attack.
	Label      string            `json:"label"`
	Parameters []AttackParameter `json:"parameters"`

	// HTTP endpoint which the Steadybit platform/agent could communicate with.
	Prepare MutatingEndpointReference `json:"prepare"`

	// HTTP endpoint which the Steadybit platform/agent could communicate with.
	Start MutatingEndpointReference `json:"start"`

	// HTTP endpoint which the Steadybit platform/agent could communicate with.
	Status *MutatingEndpointReferenceWithCallInterval `json:"status,omitempty"`

	// HTTP endpoint which the Steadybit platform/agent could communicate with.
	Stop *MutatingEndpointReference `json:"stop,omitempty"`

	// What target type this attack should be offered for. Matches the `id` field within `DescribeTargetTypeResponse` within DiscoveryKit.
	TargetType *string `json:"targetType,omitempty"`

	// Attacks can either be an instantaneous event, e.g., the restart of a host, or an activity spanning over an unspecified duration. For those attacks having a duration, we differentiate between internally, e.g., waiting for a deployment to finish, and externally, e.g., waiting for a user-specified time to pass, controlled durations.
	TimeControl AttackDescriptionTimeControl `json:"timeControl"`

	// The version of the attack. Remember to increase the value everytime you update the definitions. The platform will ignore any definition changes with the same attack version. We do recommend usage of semver strings.
	Version string `json:"version"`
}

// Describes what kind of attack this is. This is used to help users understand and classify the various runnable actions that are part of an experiment.
type AttackDescriptionKind string

// Attacks can either be an instantaneous event, e.g., the restart of a host, or an activity spanning over an unspecified duration. For those attacks having a duration, we differentiate between internally, e.g., waiting for a deployment to finish, and externally, e.g., waiting for a user-specified time to pass, controlled durations.
type AttackDescriptionTimeControl string

// RFC 7807 Problem Details for HTTP APIs compliant response body for error scenarios
type AttackKitError struct {
	// A human-readable explanation specific to this occurrence of the problem.
	Detail *string `json:"detail,omitempty"`

	// A URI reference that identifies the specific occurrence of the problem.
	Instance *string `json:"instance,omitempty"`

	// A short, human-readable summary of the problem type.
	Title string `json:"title"`

	// A URI reference that identifies the problem type.
	Type *string `json:"type,omitempty"`
}

// Lists all attacks that the platform/agent could execute.
type AttackList struct {
	Attacks []DescribingEndpointReference `json:"attacks"`
}

// AttackParameter defines model for AttackParameter.
type AttackParameter struct {
	// Unique file type specifiers describing what type of files are accepted for parameters of type 'file'.
	AcceptedFileTypes *[]string `json:"acceptedFileTypes,omitempty"`

	// Whether this parameter should be placed under the expandable advanced section within the user interface.
	Advanced *bool `json:"advanced,omitempty"`

	// A default value for this parameter. This value will be used if the user does not specify a value for this parameter.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// Description for end-users to help them understand the attack parameter.
	Description *string `json:"description,omitempty"`

	// A human-readable label for the attack parameter.
	Label string `json:"label"`

	// The key under which the attack parameter is stored. This key can then be found within the prepare request's config field.
	Name string `json:"name"`

	// Optional options for the `string`, `string[]` and `string_array` parameter types. Which result in suggestions for end-users.
	Options *[]ParameterOption `json:"options,omitempty"`

	// You can define this fields to order the parameters in the user interface. The lower the value, the higher the position.
	Order *int `json:"order,omitempty"`

	// Whether or not end-users need to specify a value for this parameter.
	Required *bool `json:"required,omitempty"`

	// What kind of value this parameter is capturing. The type selection influences the `config` passed as part of the `PrepareRequest`. It also results in improved user-interface elements.
	Type AttackParameterType `json:"type"`
}

// What kind of value this parameter is capturing. The type selection influences the `config` passed as part of the `PrepareRequest`. It also results in improved user-interface elements.
type AttackParameterType string

// Any kind of attack specific state that will be passed to the next endpoints.
type AttackState = map[string]interface{}

// HTTP endpoint which the Steadybit platform/agent could communicate with.
type DescribingEndpointReference struct {
	// HTTP method to use when calling the HTTP endpoint.
	Method DescribingEndpointReferenceMethod `json:"method"`

	// Absolute path of the HTTP endpoint.
	Path string `json:"path"`
}

// HTTP method to use when calling the HTTP endpoint.
type DescribingEndpointReferenceMethod string

// Log-message that will be passed to the agent log.
type Message struct {
	Level   *MessageLevel `json:"level,omitempty"`
	Message string        `json:"message"`
}

// MessageLevel defines model for Message.Level.
type MessageLevel string

// Log-messages that will be passed to the agent log.
type Messages = []Message

// HTTP endpoint which the Steadybit platform/agent could communicate with.
type MutatingEndpointReference struct {
	Method MutatingHttpMethod `json:"method"`

	// Absolute path of the HTTP endpoint.
	Path string `json:"path"`
}

// MutatingEndpointReferenceWithCallInterval defines model for MutatingEndpointReferenceWithCallInterval.
type MutatingEndpointReferenceWithCallInterval struct {
	// At what frequency should the state endpoint be called? Takes durations in the format of `100ms` or `10s`.
	CallInterval *string            `json:"callInterval,omitempty"`
	Method       MutatingHttpMethod `json:"method"`

	// Absolute path of the HTTP endpoint.
	Path string `json:"path"`
}

// MutatingHttpMethod defines model for MutatingHttpMethod.
type MutatingHttpMethod string

// ParameterOption defines model for ParameterOption.
type ParameterOption struct {
	// A human-readable label describing this option.
	Label string `json:"label"`

	// The technical value which will be passed to the attack as part of the `config` object.
	Value string `json:"value"`
}

// PrepareResult defines model for PrepareResult.
type PrepareResult struct {
	Artifacts *Artifacts `json:"artifacts,omitempty"`

	// Log-messages that will be passed to the agent log.
	Messages *Messages `json:"messages,omitempty"`

	// Any kind of attack specific state that will be passed to the next endpoints.
	State AttackState `json:"state"`
}

// StartResult defines model for StartResult.
type StartResult struct {
	Artifacts *Artifacts `json:"artifacts,omitempty"`

	// Log-messages that will be passed to the agent log.
	Messages *Messages `json:"messages,omitempty"`

	// Any kind of attack specific state that will be passed to the next endpoints.
	State *AttackState `json:"state,omitempty"`
}

// StatusResult defines model for StatusResult.
type StatusResult struct {
	Artifacts *Artifacts `json:"artifacts,omitempty"`
	Completed bool       `json:"completed"`

	// Log-messages that will be passed to the agent log.
	Messages *Messages `json:"messages,omitempty"`

	// Any kind of attack specific state that will be passed to the next endpoints.
	State *AttackState `json:"state,omitempty"`
}

// StopResult defines model for StopResult.
type StopResult struct {
	Artifacts *Artifacts `json:"artifacts,omitempty"`

	// Log-messages that will be passed to the agent log.
	Messages *Messages `json:"messages,omitempty"`
}

// The target to attack as identified by a discovery.
type Target struct {
	// These attributes include detailed information about the target provided through the discovery. These attributes are typically used as additional parameters within the attack implementation.
	Attributes map[string][]string `json:"attributes"`
	Name       string              `json:"name"`
}

// AttackListResponse defines model for AttackListResponse.
type AttackListResponse struct {
	union json.RawMessage
}

// AttackStatusResponse defines model for AttackStatusResponse.
type AttackStatusResponse struct {
	union json.RawMessage
}

// DescribeAttackResponse defines model for DescribeAttackResponse.
type DescribeAttackResponse struct {
	union json.RawMessage
}

// PrepareAttackResponse defines model for PrepareAttackResponse.
type PrepareAttackResponse struct {
	union json.RawMessage
}

// StartAttackResponse defines model for StartAttackResponse.
type StartAttackResponse struct {
	union json.RawMessage
}

// StopAttackResponse defines model for StopAttackResponse.
type StopAttackResponse struct {
	union json.RawMessage
}

// AttackStatusRequestBody defines model for AttackStatusRequestBody.
type AttackStatusRequestBody struct {
	// Any kind of attack specific state that will be passed to the next endpoints.
	State AttackState `json:"state"`
}

// PrepareAttackRequestBody defines model for PrepareAttackRequestBody.
type PrepareAttackRequestBody struct {
	// The attack configuration. This contains the end-user configuration done for the attack. Possible configuration parameters are defined through the attack description.
	Config map[string]interface{} `json:"config"`

	// The target to attack as identified by a discovery.
	Target *Target `json:"target,omitempty"`
}

// StartAttackRequestBody defines model for StartAttackRequestBody.
type StartAttackRequestBody struct {
	// Any kind of attack specific state that will be passed to the next endpoints.
	State AttackState `json:"state"`
}

// StopAttackRequestBody defines model for StopAttackRequestBody.
type StopAttackRequestBody struct {
	// Any kind of attack specific state that will be passed to the next endpoints.
	State AttackState `json:"state"`
}

func (t AttackListResponse) AsAttackList() (AttackList, error) {
	var body AttackList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *AttackListResponse) FromAttackList(v AttackList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t AttackListResponse) AsAttackKitError() (AttackKitError, error) {
	var body AttackKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *AttackListResponse) FromAttackKitError(v AttackKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t AttackListResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AttackListResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t AttackStatusResponse) AsStatusResult() (StatusResult, error) {
	var body StatusResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *AttackStatusResponse) FromStatusResult(v StatusResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t AttackStatusResponse) AsAttackKitError() (AttackKitError, error) {
	var body AttackKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *AttackStatusResponse) FromAttackKitError(v AttackKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t AttackStatusResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AttackStatusResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t DescribeAttackResponse) AsAttackDescription() (AttackDescription, error) {
	var body AttackDescription
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DescribeAttackResponse) FromAttackDescription(v AttackDescription) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DescribeAttackResponse) AsAttackKitError() (AttackKitError, error) {
	var body AttackKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *DescribeAttackResponse) FromAttackKitError(v AttackKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t DescribeAttackResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *DescribeAttackResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t PrepareAttackResponse) AsPrepareResult() (PrepareResult, error) {
	var body PrepareResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PrepareAttackResponse) FromPrepareResult(v PrepareResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PrepareAttackResponse) AsAttackKitError() (AttackKitError, error) {
	var body AttackKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *PrepareAttackResponse) FromAttackKitError(v AttackKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t PrepareAttackResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PrepareAttackResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t StartAttackResponse) AsStartResult() (StartResult, error) {
	var body StartResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *StartAttackResponse) FromStartResult(v StartResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t StartAttackResponse) AsAttackKitError() (AttackKitError, error) {
	var body AttackKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *StartAttackResponse) FromAttackKitError(v AttackKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t StartAttackResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StartAttackResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

func (t StopAttackResponse) AsStopResult() (StopResult, error) {
	var body StopResult
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *StopAttackResponse) FromStopResult(v StopResult) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t StopAttackResponse) AsAttackKitError() (AttackKitError, error) {
	var body AttackKitError
	err := json.Unmarshal(t.union, &body)
	return body, err
}

func (t *StopAttackResponse) FromAttackKitError(v AttackKitError) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

func (t StopAttackResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StopAttackResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}
